type VotingStats = 
 record {
   averageApprovalRate: nat;
   averageConfidence: nat;
   mostActiveInvestor: opt text;
   totalReportsVoted: nat;
   totalVotes: nat;
 };
type VoteType = 
 variant {
   Abstain;
   Approve;
   Reject;
 };
type VoteSummary = 
 record {
   abstainVotes: nat;
   approvalRate: nat;
   approveVotes: nat;
   averageConfidence: nat;
   lastVoteTime: opt Time;
   negativeFeedback: nat;
   neutralFeedback: nat;
   positiveFeedback: nat;
   rejectVotes: nat;
   reportId: text;
   totalVotes: nat;
 };
type VoteRequest = 
 record {
   confidence: nat;
   feedback: opt text;
   feedbackType: opt FeedbackType;
   reportId: text;
   vote: VoteType;
 };
type UserType = 
 variant {
   Founder;
   Investor;
 };
type TransferResponse = 
 variant {
   Error: text;
   Success:
    record {
      amount: nat;
      blockIndex: nat;
      toAccount: TransferAccount;
      tokenType: text;
      transactionId: text;
    };
 };
type TransferNFTResponse = 
 variant {
   Error: text;
   Success: record {
              tokenId: nat;
              transactionId: opt text;
            };
 };
type TransferNFTRequest = 
 record {
   memo: opt text;
   toAccount: NFTAccount;
   tokenId: nat;
 };
type TransferArgs = 
 record {
   amount: nat;
   memo: opt text;
   toAccount: TransferAccount;
   tokenType: text;
 };
type TransferAccount = 
 record {
   owner: principal;
   subaccount: opt blob;
 };
type TopUpResponse = 
 variant {
   Error: text;
   Success:
    record {
      amount: nat;
      isFullyPaid: bool;
      newTotal: nat;
      remainingAmount: nat;
      tokenType: text;
      topUpId: text;
      transactionId: text;
    };
 };
type TopUpRequest = 
 record {
   amount: nat;
   memo: opt text;
   startupId: text;
   tokenType: text;
 };
type TokenInfoResponse = 
 variant {
   Error: text;
   Success:
    record {
      decimals: nat8;
      fee: nat;
      name: text;
      symbol: text;
      tokenType: text;
    };
 };
type TokenConfig = 
 record {
   canisterId: text;
   decimals: nat8;
   fee: nat;
   ledgerId: text;
   name: text;
   symbol: text;
 };
type Time = int;
type TeamMember = 
 record {
   background: text;
   email: text;
   id: nat;
   isFounder: bool;
   linkedin: text;
   name: text;
   photo: opt text;
   role: text;
 };
type StartupCreationRequest = 
 record {
   advisors: text;
   businessPlan: opt text;
   companyImages: vec text;
   companyLogo: opt text;
   companyType: text;
   competitiveAdvantage: text;
   description: text;
   financialProjections: opt text;
   foundedYear: text;
   founderBackground: text;
   fundingGoal: text;
   legalDocuments: opt text;
   location: text;
   marketingStrategy: text;
   monthlyExpenses: text;
   monthlyRevenue: text;
   nftImage: opt text;
   nftPrice: text;
   operationalProcess: text;
   periodicProfitSharing: text;
   problemStatement: text;
   revenueModel: text;
   sector: text;
   solution: text;
   startupName: text;
   status: text;
   targetMarket: text;
   teamMembers: vec TeamMember;
   useOfFunds: text;
   website: text;
 };
type Startup = 
 record {
   advisors: text;
   businessPlan: opt text;
   companyImages: vec text;
   companyLogo: opt text;
   companyType: text;
   competitiveAdvantage: text;
   createdAt: Time;
   description: text;
   financialProjections: opt text;
   foundedYear: text;
   founderBackground: text;
   founderId: text;
   fundingGoal: text;
   id: text;
   legalDocuments: opt text;
   location: text;
   marketingStrategy: text;
   monthlyExpenses: text;
   monthlyRevenue: text;
   nftImage: opt text;
   nftPrice: text;
   operationalProcess: text;
   periodicProfitSharing: text;
   problemStatement: text;
   revenueModel: text;
   sector: text;
   solution: text;
   startupName: text;
   status: text;
   targetMarket: text;
   teamMembers: vec TeamMember;
   updatedAt: Time;
   useOfFunds: text;
   website: text;
 };
type Result_9 = 
 variant {
   err: text;
   ok: VoteSummary;
 };
type Result_8 = 
 variant {
   err: text;
   ok: MintNFTResponse;
 };
type Result_7 = 
 variant {
   err: text;
   ok: text;
 };
type Result_6 = 
 variant {
   err: text;
   ok: NFTPurchaseResponse;
 };
type Result_5 = 
 variant {
   err: text;
   ok: Founder;
 };
type Result_4 = 
 variant {
   err: text;
   ok: Investor;
 };
type Result_3 = 
 variant {
   err: text;
   ok: TopUpResponse;
 };
type Result_24 = 
 variant {
   err: text;
   ok: bool;
 };
type Result_23 = 
 variant {
   err: text;
   ok: Startup;
 };
type Result_22 = 
 variant {
   err: text;
   ok: CollateralInfo;
 };
type Result_21 = 
 variant {
   err: text;
   ok: vec CollateralTopUp;
 };
type Result_20 = 
 variant {
   err: text;
   ok: opt InvestorVote;
 };
type Result_2 = 
 variant {
   err: text;
   ok: TransferNFTResponse;
 };
type Result_19 = 
 variant {
   err: text;
   ok: InvestorVoteHistory;
 };
type Result_18 = 
 variant {
   err: text;
   ok: MonthlyReportList;
 };
type Result_17 = 
 variant {
   err: text;
   ok: NFTBalanceResponse;
 };
type Result_16 = 
 variant {
   err: text;
   ok: NFTInfo;
 };
type Result_15 = 
 variant {
   err: text;
   ok: NFTOwnerResponse;
 };
type Result_14 = 
 variant {
   err: text;
   ok: nat;
 };
type Result_13 = 
 variant {
   err: text;
   ok: vec NFTInfo;
 };
type Result_12 = 
 variant {
   err: text;
   ok: NFTPurchaseInfo;
 };
type Result_11 = 
 variant {
   err: text;
   ok: ReportVoteDetails;
 };
type Result_10 = 
 variant {
   err: text;
   ok: NFTPurchaseHistory;
 };
type Result_1 = 
 variant {
   err: text;
   ok: MonthlyReport;
 };
type Result = 
 variant {
   err: text;
   ok: InvestorVote;
 };
type ReportVoteDetails = 
 record {
   individualVotes: vec InvestorVote;
   reportId: text;
   summary: VoteSummary;
 };
type NFTPurchaseStats = 
 record {
   averagePurchaseAmount: nat;
   topStartup: opt text;
   totalNFTsSold: nat;
   totalPurchases: nat;
   totalRevenue: nat;
 };
type NFTPurchaseResponse = 
 variant {
   Error: text;
   Success:
    record {
      amount: nat;
      change: nat;
      investorId: text;
      nftPrice: nat;
      startupId: text;
      tokenId: nat;
      transactionId: text;
    };
 };
type NFTPurchaseRequest = 
 record {
   amount: nat;
   investorId: text;
   memo: opt text;
   startupId: text;
 };
type NFTPurchaseInfo = 
 record {
   amount: nat;
   change: nat;
   id: text;
   investorId: text;
   nftPrice: nat;
   startupId: text;
   status: text;
   timestamp: Time;
   tokenId: nat;
   transactionId: text;
 };
type NFTPurchaseHistory = 
 record {
   purchases: vec NFTPurchaseInfo;
   totalNFTs: nat;
   totalPurchases: nat;
   totalSpent: nat;
 };
type NFTOwnerResponse = 
 variant {
   Error: text;
   Success: record {
              owner: opt NFTAccount;
              tokenId: nat;
            };
 };
type NFTMetadata = 
 record {
   attributes: opt vec record {
                         text;
                         text;
                       };
   description: opt text;
   image: opt text;
   name: opt text;
   tokenUri: text;
 };
type NFTInfo = 
 record {
   metadata: NFTMetadata;
   mintedAt: Time;
   owner: NFTAccount;
   startupId: text;
   tokenId: nat;
 };
type NFTConfig = 
 record {
   atomicBatchTransfers: opt bool;
   canisterId: text;
   defaultTakeValue: opt nat;
   description: text;
   logo: opt text;
   maxMemoSize: nat;
   maxQueryBatchSize: opt nat;
   maxTakeValue: opt nat;
   maxUpdateBatchSize: opt nat;
   name: text;
   permittedDrift: nat;
   supplyCap: opt nat;
   symbol: text;
   txWindow: nat;
 };
type NFTBalanceResponse = 
 variant {
   Error: text;
   Success: record {
              account: NFTAccount;
              balance: nat;
            };
 };
type NFTAccount = 
 record {
   owner: principal;
   subaccount: opt blob;
 };
type MonthlyReportStatus = 
 variant {
   Approved;
   Draft;
   Rejected;
   Submitted;
 };
type MonthlyReportStats = 
 record {
   averageMonthlyExpenses: nat;
   averageMonthlyProfit: nat;
   averageMonthlyRevenue: nat;
   bestMonth: opt text;
   totalExpenses: nat;
   totalProfit: nat;
   totalProfitSharing: nat;
   totalReports: nat;
   totalRevenue: nat;
   worstMonth: opt text;
 };
type MonthlyReportRequest = 
 record {
   expenses: nat;
   investorCount: nat;
   month: nat;
   newInvestors: nat;
   profit: nat;
   profitSharingAmount: nat;
   revenue: nat;
   startupId: text;
   year: nat;
 };
type MonthlyReportList = 
 record {
   reports: vec MonthlyReport;
   totalExpenses: nat;
   totalProfit: nat;
   totalProfitSharing: nat;
   totalReports: nat;
   totalRevenue: nat;
 };
type MonthlyReport = 
 record {
   approvedAt: opt Time;
   createdAt: Time;
   expenses: nat;
   id: text;
   investorCount: nat;
   month: nat;
   newInvestors: nat;
   profit: nat;
   profitSharingAmount: nat;
   revenue: nat;
   startupId: text;
   status: MonthlyReportStatus;
   submittedAt: opt Time;
   updatedAt: Time;
   year: nat;
 };
type MintNFTResponse = 
 variant {
   Error: text;
   Success: record {
              startupId: text;
              tokenId: nat;
              transactionId: opt text;
            };
 };
type MintNFTRequest = 
 record {
   memo: opt text;
   metadata: NFTMetadata;
   startupId: text;
   toAccount: NFTAccount;
 };
type InvestorVoteHistory = 
 record {
   approvalRate: nat;
   averageConfidence: nat;
   totalVotes: nat;
   votes: vec InvestorVote;
 };
type InvestorVote = 
 record {
   confidence: nat;
   feedback: opt text;
   feedbackType: opt FeedbackType;
   id: text;
   investorId: text;
   reportId: text;
   timestamp: Time;
   vote: VoteType;
 };
type InvestorRegistrationRequest = 
 record {
   availableCapital: text;
   city: text;
   country: text;
   email: text;
   fullName: text;
   investmentExperience: text;
   investmentGoals: text;
   monthlyBudget: text;
   phone: text;
   riskTolerance: text;
 };
type Investor = 
 record {
   availableCapital: text;
   city: text;
   country: text;
   createdAt: Time;
   email: text;
   fullName: text;
   id: text;
   investmentExperience: text;
   investmentGoals: text;
   monthlyBudget: text;
   phone: text;
   "principal": principal;
   riskTolerance: text;
   updatedAt: Time;
 };
type FounderRegistrationRequest = 
 record {
   address: text;
   email: text;
   experience: text;
   expertise: text;
   fullName: text;
   idNumber: text;
   linkedIn: text;
   phone: text;
   previousBusinesses: text;
   taxNumber: text;
 };
type Founder = 
 record {
   address: text;
   createdAt: Time;
   email: text;
   experience: text;
   expertise: text;
   fullName: text;
   id: text;
   idNumber: text;
   linkedIn: text;
   phone: text;
   previousBusinesses: text;
   "principal": principal;
   taxNumber: text;
   updatedAt: Time;
 };
type FeedbackType = 
 variant {
   Negative;
   Neutral;
   Positive;
 };
type EnvironmentConfig = 
 record {
   ckUSDCToken: TokenConfig;
   environment: text;
   icpToken: TokenConfig;
   nftToken: NFTConfig;
   plantifyAccount: text;
   useTestTokens: bool;
 };
type CollateralTopUp = 
 record {
   amount: nat;
   id: text;
   startupId: text;
   status: text;
   timestamp: Time;
   tokenType: text;
   transactionId: opt text;
 };
type CollateralStatus = 
 variant {
   Active;
   Locked;
   Pending;
   Released;
 };
type CollateralProgressResponse = 
 variant {
   Error: text;
   Success: CollateralProgress;
 };
type CollateralProgress = 
 record {
   currentAmount: nat;
   isFullyPaid: bool;
   percentage: nat;
   requiredAmount: nat;
   status: text;
   tokenType: text;
 };
type CollateralInfo = 
 record {
   createdAt: Time;
   currentAmount: nat;
   lockEndTime: opt Time;
   lockStartTime: opt Time;
   requiredAmount: nat;
   startupId: text;
   status: CollateralStatus;
   tokenType: text;
   topUpHistory: vec CollateralTopUp;
   updatedAt: Time;
 };
type BalanceResponse = 
 variant {
   Error: text;
   Success: record {
              account: TransferAccount;
              balance: nat;
              tokenType: text;
            };
 };
service : {
  approveMonthlyReport: (reportId: text) -> (Result_1);
  calculateRequiredCollateral: (monthlyProfitSharing: nat, tokenType:
   text) -> (nat);
  canInvestorVote: (reportId: text) -> (Result_24);
  canMintNFT: (startupId: text) -> (Result_24);
  canPurchaseNFT: (investorId: text, startupId: text) -> (Result_24);
  castVote: (request: VoteRequest) -> (Result);
  createMonthlyReport: (request: MonthlyReportRequest) -> (Result_1);
  createStartup: (request: StartupCreationRequest) -> (Result_23);
  createStartupForFounder: (founderId: text, request:
   StartupCreationRequest) -> (Result_23);
  getAllCollateralInfo: () -> (vec CollateralInfo);
  getAllMonthlyReports: () -> (vec MonthlyReport);
  getAllNFTs: () -> (vec NFTInfo);
  getAllPurchases: () -> (vec NFTPurchaseInfo);
  getAllStartups: () -> (vec Startup);
  getAllVotes: () -> (vec InvestorVote);
  getBalance: (account: TransferAccount, tokenType: text) ->
   (BalanceResponse);
  getCanisterVersion: () -> (nat);
  getCkUSDCBalance: (account: TransferAccount) -> (BalanceResponse);
  getCkUSDCTokenConfig: () -> (TokenConfig);
  getCollateralProgress: (startupId: text) -> (CollateralProgressResponse);
  getCollateralStatus: (startupId: text) -> (Result_22);
  getCollateralTopUpHistory: (startupId: text) -> (Result_21);
  getCollectionInfo: () -> (NFTConfig);
  getEnvironment: () -> (text);
  getEnvironmentConfig: () -> (EnvironmentConfig);
  getFeaturedStartup: () -> (opt Startup);
  getFounderByPrincipal: () -> (opt Founder);
  getFounders: () -> (vec Founder);
  getICPBalance: (account: TransferAccount) -> (BalanceResponse);
  getICPTokenConfig: () -> (TokenConfig);
  getInvestorByPrincipal: () -> (opt Investor);
  getInvestorPurchaseHistory: (investorId: text) -> (Result_10);
  getInvestorVoteForReport: (reportId: text) -> (Result_20);
  getInvestorVoteHistory: (investorId: text) -> (Result_19);
  getInvestors: () -> (vec Investor);
  getMonthlyReport: (reportId: text) -> (Result_1);
  getMonthlyReportStats: () -> (MonthlyReportStats);
  getMonthlyReportsByStartup: (startupId: text) -> (Result_18);
  getMonthlyReportsByStatus: (status: MonthlyReportStatus) ->
   (vec MonthlyReport);
  getNFTBalance: (account: NFTAccount) -> (Result_17);
  getNFTInfo: (tokenId: nat) -> (Result_16);
  getNFTOwner: (tokenId: nat) -> (Result_15);
  getNFTPrice: (startupId: text) -> (Result_14);
  getNFTStats: () ->
   (record {
      nextTokenId: nat;
      totalStartups: nat;
      totalSupply: nat;
    });
  getNFTsByStartup: (startupId: text) -> (Result_13);
  getPlantifyAccount: () -> (text);
  getPurchaseInfo: (purchaseId: text) -> (Result_12);
  getPurchaseStats: () -> (NFTPurchaseStats);
  getReportVoteDetails: (reportId: text) -> (Result_11);
  getReportVotes: (reportId: text) -> (vec InvestorVote);
  getStartupDetails: (startupId: text) -> (opt Startup);
  getStartupPurchaseHistory: (startupId: text) -> (Result_10);
  getTokenCanisterId: (tokenType: text) -> (opt text);
  getTokenInfo: (tokenType: text) -> (TokenInfoResponse);
  getUserType: () -> (opt UserType);
  getVoteSummary: (reportId: text) -> (Result_9);
  getVotingStats: () -> (VotingStats);
  initializeCollateral: (startupId: text, requiredAmount: nat, tokenType:
   text) -> (Result_7);
  isUserFounder: () -> (bool);
  isUserInvestor: () -> (bool);
  isUsingTestTokens: () -> (bool);
  mintNFT: (request: MintNFTRequest) -> (Result_8);
  mintNFTForStartup: (startupId: text) -> (Result_7);
  purchaseNFT: (request: NFTPurchaseRequest) -> (Result_6);
  registerFounder: (request: FounderRegistrationRequest) -> (Result_5);
  registerInvestor: (request: InvestorRegistrationRequest) -> (Result_4);
  rejectMonthlyReport: (reportId: text) -> (Result_1);
  submitMonthlyReport: (reportId: text) -> (Result_1);
  topUpCollateral: (request: TopUpRequest) -> (Result_3);
  transferCkUSDC: (toAccount: TransferAccount, amount: nat, memo:
   opt text) -> (TransferResponse);
  transferICP: (toAccount: TransferAccount, amount: nat, memo: opt text) ->
   (TransferResponse);
  transferNFT: (request: TransferNFTRequest) -> (Result_2);
  transferTokens: (args: TransferArgs) -> (TransferResponse);
  updateMonthlyReport: (reportId: text, request: MonthlyReportRequest) ->
   (Result_1);
  updateStartupStatus: (startupId: text, newStatus: text) -> (bool);
  updateVote: (reportId: text, request: VoteRequest) -> (Result);
  whoami: () -> (principal);
}
