type VotingStats = 
 record {
   averageApprovalRate: nat;
   averageConfidence: nat;
   mostActiveInvestor: opt text;
   totalReportsVoted: nat;
   totalVotes: nat;
 };
type VoteType = 
 variant {
   Abstain;
   Approve;
   Reject;
 };
type VoteSummary = 
 record {
   abstainVotes: nat;
   approvalRate: nat;
   approveVotes: nat;
   averageConfidence: nat;
   lastVoteTime: opt Time;
   negativeFeedback: nat;
   neutralFeedback: nat;
   positiveFeedback: nat;
   rejectVotes: nat;
   reportId: text;
   totalVotes: nat;
 };
type VoteRequest = 
 record {
   confidence: nat;
   feedback: opt text;
   feedbackType: opt FeedbackType;
   reportId: text;
   vote: VoteType;
 };
type UserType = 
 variant {
   Founder;
   Investor;
 };
type TransferResponse = 
 variant {
   Error: text;
   Success:
    record {
      amount: nat;
      blockIndex: nat;
      toAccount: TransferAccount;
      tokenType: text;
      transactionId: text;
    };
 };
type TransferNFTResponse = 
 variant {
   Error: text;
   Success: record {
              tokenId: nat;
              transactionId: opt text;
            };
 };
type TransferNFTRequest = 
 record {
   memo: opt text;
   toAccount: NFTAccount;
   tokenId: nat;
 };
type TransferArgs = 
 record {
   amount: nat;
   memo: opt text;
   toAccount: TransferAccount;
   tokenType: text;
 };
type TransferAccount = 
 record {
   owner: principal;
   subaccount: opt vec nat8;
 };
type TopUpResponse = 
 variant {
   Error: text;
   Success:
    record {
      amount: nat;
      isFullyPaid: bool;
      newTotal: nat;
      remainingAmount: nat;
      tokenType: text;
      topUpId: text;
      transactionId: text;
    };
 };
type TopUpRequest = 
 record {
   amount: nat;
   memo: opt text;
   startupId: text;
   tokenType: text;
 };
type TopInvestor = 
 record {
   investorId: text;
   investorName: text;
   lastInvestmentDate: Time;
   numberOfInvestments: nat;
   profilePhoto: opt text;
   totalInvested: nat;
 };
type TokenInfoResponse = 
 variant {
   Error: text;
   Success:
    record {
      decimals: nat8;
      fee: nat;
      name: text;
      symbol: text;
      tokenType: text;
    };
 };
type TokenConfig = 
 record {
   canisterId: text;
   decimals: nat8;
   fee: nat;
   ledgerId: text;
   name: text;
   symbol: text;
 };
type Time = int;
type TeamMembersResponse = 
 variant {
   Error: text;
   Success: vec TeamMemberOverview;
 };
type TeamMemberOverview = 
 record {
   background: text;
   email: text;
   id: nat;
   isFounder: bool;
   linkedin: text;
   name: text;
   photo: opt text;
   role: text;
 };
type TeamMember = 
 record {
   background: text;
   email: text;
   id: nat;
   isFounder: bool;
   linkedin: text;
   name: text;
   photo: opt text;
   role: text;
 };
type StartupSummary = 
 record {
   availableNFTs: nat;
   builtByCaffeineAI: opt bool;
   companyImages: vec text;
   companyType: text;
   description: text;
   id: text;
   nftPrice: text;
   startupName: text;
   totalFunded: nat;
   totalFunding: text;
 };
type StartupOverviewResponse = 
 variant {
   Error: text;
   Success: StartupOverview;
 };
type StartupOverview = 
 record {
   companyType: text;
   description: text;
   fundTarget: nat;
   location: text;
   name: text;
   totalFunded: nat;
   totalNFT: nat;
   totalNFTSale: nat;
   totalTeamMembers: nat;
 };
type StartupCreationRequest = 
 record {
   advisors: text;
   builtByCaffeineAI: opt bool;
   businessPlan: opt text;
   companyImages: vec text;
   companyLogo: opt text;
   companyType: text;
   competitiveAdvantage: text;
   description: text;
   financialProjections: opt text;
   foundedYear: text;
   founderBackground: text;
   fundingGoal: text;
   legalDocuments: opt text;
   location: text;
   marketingStrategy: text;
   monthlyExpenses: text;
   monthlyRevenue: text;
   nftImage: opt text;
   nftPrice: text;
   operationalProcess: text;
   periodicProfitSharing: text;
   problemStatement: text;
   revenueModel: text;
   sector: text;
   solution: text;
   startupName: text;
   status: text;
   targetMarket: text;
   teamMembers: vec TeamMember;
   useOfFunds: text;
   website: text;
 };
type Startup = 
 record {
   advisors: text;
   builtByCaffeineAI: opt bool;
   businessPlan: opt text;
   companyImages: vec text;
   companyLogo: opt text;
   companyType: text;
   competitiveAdvantage: text;
   createdAt: Time;
   description: text;
   financialProjections: opt text;
   foundedYear: text;
   founderBackground: text;
   founderId: text;
   fundingGoal: text;
   id: text;
   legalDocuments: opt text;
   location: text;
   marketingStrategy: text;
   monthlyExpenses: text;
   monthlyRevenue: text;
   nftImage: opt text;
   nftPrice: text;
   operationalProcess: text;
   periodicProfitSharing: text;
   problemStatement: text;
   revenueModel: text;
   sector: text;
   solution: text;
   startupName: text;
   status: text;
   targetMarket: text;
   teamMembers: vec TeamMember;
   totalFunded: nat;
   updatedAt: Time;
   useOfFunds: text;
   website: text;
 };
type Result_9 = 
 variant {
   err: text;
   ok: NFTPurchaseHistory;
 };
type Result_8 = 
 variant {
   err: text;
   ok: VoteSummary;
 };
type Result_7 = 
 variant {
   err: text;
   ok: MintNFTResponse;
 };
type Result_6 = 
 variant {
   err: text;
   ok: text;
 };
type Result_5 = 
 variant {
   err: text;
   ok: Founder;
 };
type Result_4 = 
 variant {
   err: text;
   ok: TopUpResponse;
 };
type Result_3 = 
 variant {
   err: text;
   ok: TransferNFTResponse;
 };
type Result_23 = 
 variant {
   err: text;
   ok: bool;
 };
type Result_22 = 
 variant {
   err: text;
   ok: Startup;
 };
type Result_21 = 
 variant {
   err: text;
   ok: CollateralInfo;
 };
type Result_20 = 
 variant {
   err: text;
   ok: vec CollateralTopUp;
 };
type Result_2 = 
 variant {
   err: text;
   ok: Investor;
 };
type Result_19 = 
 variant {
   err: text;
   ok: opt InvestorVote;
 };
type Result_18 = 
 variant {
   err: text;
   ok: InvestorVoteHistory;
 };
type Result_17 = 
 variant {
   err: text;
   ok: MonthlyReportList;
 };
type Result_16 = 
 variant {
   err: text;
   ok: NFTBalanceResponse;
 };
type Result_15 = 
 variant {
   err: text;
   ok: NFTInfo;
 };
type Result_14 = 
 variant {
   err: text;
   ok: NFTOwnerResponse;
 };
type Result_13 = 
 variant {
   err: text;
   ok: nat;
 };
type Result_12 = 
 variant {
   err: text;
   ok: vec NFTInfo;
 };
type Result_11 = 
 variant {
   err: text;
   ok: NFTPurchaseInfo;
 };
type Result_10 = 
 variant {
   err: text;
   ok: ReportVoteDetails;
 };
type Result_1 = 
 variant {
   err: text;
   ok: MonthlyReport;
 };
type Result = 
 variant {
   err: text;
   ok: InvestorVote;
 };
type ReportVoteDetails = 
 record {
   individualVotes: vec InvestorVote;
   reportId: text;
   summary: VoteSummary;
 };
type RecentInvestmentSummary = 
 record {
   amount: nat;
   date: Time;
   investorId: text;
   investorName: text;
   startupId: text;
   startupName: text;
   tokenType: text;
 };
type RecentInvestment = 
 record {
   amount: nat;
   date: Time;
   investorName: text;
   tokenType: text;
 };
type PortfolioSummary = 
 record {
   activeInvestments: nat;
   averageReturn: nat;
   bestPerformer: opt text;
   completedInvestments: nat;
   totalMonthlyCommitments: nat;
   totalProfitSharingEarnings: nat;
   totalStartups: nat;
   worstPerformer: opt text;
 };
type PortfolioItem = 
 record {
   currentValue: nat;
   investedAmount: nat;
   investmentDate: Time;
   lastUpdateDate: Time;
   monthlyCommitment: nat;
   nftCount: nat;
   profitSharingEarnings: nat;
   returnAmount: nat;
   returnPercentage: nat;
   sector: text;
   startupId: text;
   startupLogo: opt text;
   startupName: text;
   status: text;
 };
type PerformanceMetrics = 
 record {
   diversificationScore: nat;
   investmentTrend: text;
   monthlyCommitmentTrend: text;
   portfolioGrowth: nat;
   profitSharingTrend: text;
   riskScore: nat;
 };
type PaginationParams = 
 record {
   limit: nat;
   page: nat;
 };
type PaginatedStartups = 
 record {
   limit: nat;
   page: nat;
   startups: vec StartupSummary;
   totalCount: nat;
   totalPages: nat;
 };
type NFTPurchaseStats = 
 record {
   averagePurchaseAmount: nat;
   topStartup: opt text;
   totalNFTsSold: nat;
   totalPurchases: nat;
   totalRevenue: nat;
 };
type NFTPurchaseResponse = 
 variant {
   Error: text;
   Success:
    record {
      investorId: text;
      nftPrice: nat;
      quantity: nat;
      startupId: text;
      tokenIds: vec nat;
      totalAmount: nat;
      transactionId: text;
    };
 };
type NFTPurchaseRequest = 
 record {
   investorId: text;
   memo: opt text;
   quantity: nat;
   startupId: text;
 };
type NFTPurchaseInfo = 
 record {
   amount: nat;
   change: nat;
   id: text;
   investorId: text;
   nftPrice: nat;
   startupId: text;
   status: text;
   timestamp: Time;
   tokenId: nat;
   transactionId: text;
 };
type NFTPurchaseHistory = 
 record {
   purchases: vec NFTPurchaseInfo;
   totalNFTs: nat;
   totalPurchases: nat;
   totalSpent: nat;
 };
type NFTOwnerResponse = 
 variant {
   Error: text;
   Success: record {
              owner: opt NFTAccount;
              tokenId: nat;
            };
 };
type NFTMetadata = 
 record {
   attributes: opt vec record {
                         text;
                         text;
                       };
   description: opt text;
   image: opt text;
   name: opt text;
   tokenUri: text;
 };
type NFTInfo = 
 record {
   metadata: NFTMetadata;
   mintedAt: Time;
   owner: NFTAccount;
   startupId: text;
   tokenId: nat;
 };
type NFTConfig = 
 record {
   atomicBatchTransfers: opt bool;
   canisterId: text;
   defaultTakeValue: opt nat;
   description: text;
   logo: opt text;
   maxMemoSize: nat;
   maxQueryBatchSize: opt nat;
   maxTakeValue: opt nat;
   maxUpdateBatchSize: opt nat;
   name: text;
   permittedDrift: nat;
   supplyCap: opt nat;
   symbol: text;
   txWindow: nat;
 };
type NFTBalanceResponse = 
 variant {
   Error: text;
   Success: record {
              account: NFTAccount;
              balance: nat;
            };
 };
type NFTAccount = 
 record {
   owner: principal;
   subaccount: opt blob;
 };
type MyInvestmentPortfolioResponse = 
 variant {
   Error: text;
   Success: MyInvestmentPortfolio;
 };
type MyInvestmentPortfolio = 
 record {
   performanceMetrics: PerformanceMetrics;
   portfolioItems: vec PortfolioItem;
   portfolioSummary: PortfolioSummary;
   returnPercentage: nat;
   totalInvested: nat;
   totalPortfolioValue: nat;
   totalReturns: nat;
 };
type MonthlyReportStatus = 
 variant {
   Approved;
   Draft;
   Rejected;
   Submitted;
 };
type MonthlyReportStats = 
 record {
   averageMonthlyExpenses: nat;
   averageMonthlyProfit: nat;
   averageMonthlyRevenue: nat;
   bestMonth: opt text;
   totalExpenses: nat;
   totalProfit: nat;
   totalProfitSharing: nat;
   totalReports: nat;
   totalRevenue: nat;
   worstMonth: opt text;
 };
type MonthlyReportRequest = 
 record {
   expenses: nat;
   investorCount: nat;
   month: nat;
   newInvestors: nat;
   profit: nat;
   profitSharingAmount: nat;
   revenue: nat;
   startupId: text;
   year: nat;
 };
type MonthlyReportList = 
 record {
   reports: vec MonthlyReport;
   totalExpenses: nat;
   totalProfit: nat;
   totalProfitSharing: nat;
   totalReports: nat;
   totalRevenue: nat;
 };
type MonthlyReport = 
 record {
   approvedAt: opt Time;
   createdAt: Time;
   expenses: nat;
   id: text;
   investorCount: nat;
   month: nat;
   newInvestors: nat;
   profit: nat;
   profitSharingAmount: nat;
   revenue: nat;
   startupId: text;
   status: MonthlyReportStatus;
   submittedAt: opt Time;
   updatedAt: Time;
   year: nat;
 };
type MintNFTResponse = 
 variant {
   Error: text;
   Success: record {
              startupId: text;
              tokenId: nat;
              transactionId: opt text;
            };
 };
type MintNFTRequest = 
 record {
   memo: opt text;
   metadata: NFTMetadata;
   startupId: text;
   toAccount: NFTAccount;
 };
type InvestorVoteHistory = 
 record {
   approvalRate: nat;
   averageConfidence: nat;
   totalVotes: nat;
   votes: vec InvestorVote;
 };
type InvestorVote = 
 record {
   confidence: nat;
   feedback: opt text;
   feedbackType: opt FeedbackType;
   id: text;
   investorId: text;
   reportId: text;
   timestamp: Time;
   vote: VoteType;
 };
type InvestorStartupInvestmentResponse = 
 variant {
   Error: text;
   Success: InvestorStartupInvestment;
 };
type InvestorStartupInvestment = 
 record {
   averagePrice: nat;
   firstInvestment: Time;
   lastInvestment: Time;
   nftCount: nat;
   profitSharingEarnings: nat;
   startupId: text;
   startupName: text;
   startupStatus: text;
   totalInvested: nat;
 };
type InvestorRegistrationRequest = 
 record {
   availableCapital: text;
   bio: opt text;
   city: text;
   company: opt text;
   country: text;
   email: text;
   fullName: text;
   investmentExperience: text;
   investmentGoals: text;
   location: opt text;
   monthlyBudget: text;
   occupation: opt text;
   phone: text;
   profilePhoto: opt text;
   riskTolerance: text;
 };
type InvestorRecentInvestment = 
 record {
   amount: nat;
   date: Time;
   nftPrice: nat;
   quantity: nat;
   startupId: text;
   startupName: text;
   status: text;
 };
type InvestorProfileUpdateRequest = 
 record {
   availableCapital: opt text;
   bio: opt text;
   city: opt text;
   company: opt text;
   country: opt text;
   email: opt text;
   fullName: opt text;
   investmentExperience: opt text;
   investmentGoals: opt text;
   location: opt text;
   monthlyBudget: opt text;
   occupation: opt text;
   phone: opt text;
   profilePhoto: opt text;
   riskTolerance: opt text;
 };
type InvestorPortfolioItem = 
 record {
   averagePrice: nat;
   firstInvestment: Time;
   lastInvestment: Time;
   nftCount: nat;
   startupId: text;
   startupName: text;
   startupStatus: text;
   totalInvested: nat;
 };
type InvestorPerformanceResponse = 
 variant {
   Error: text;
   Success: InvestorPerformance;
 };
type InvestorPerformance = 
 record {
   averageInvestmentSize: nat;
   diversificationScore: nat;
   investmentTrend: text;
   profitSharingEarnings: nat;
   riskProfile: text;
   totalInvested: nat;
   totalNFTs: nat;
   uniqueStartups: nat;
 };
type InvestorGrowthData = 
 record {
   month: nat;
   newInvestors: nat;
   totalInvestors: nat;
   year: nat;
 };
type InvestorDashboardResponse = 
 variant {
   Error: text;
   Success: InvestorDashboard;
 };
type InvestorDashboardOverviewResponse = 
 variant {
   Error: text;
   Success: InvestorDashboardOverview;
 };
type InvestorDashboardOverview = 
 record {
   averageInvestmentPerStartup: nat;
   investmentPortfolio: vec InvestorPortfolioItem;
   monthlyCommitment: nat;
   profitSharingEarnings: nat;
   recentInvestments: vec InvestorRecentInvestment;
   totalAmountInvested: nat;
   totalInvestments: nat;
   totalNFTsOwned: nat;
   uniqueStartupsInvested: nat;
   votingPending: nat;
 };
type InvestorDashboard = 
 record {
   activeInvestors: nat;
   averageInvestmentPerInvestor: nat;
   investorGrowth: vec InvestorGrowthData;
   newInvestorsThisMonth: nat;
   recentInvestments: vec RecentInvestmentSummary;
   topInvestors: vec TopInvestor;
   totalInvestmentAmount: nat;
   totalInvestors: nat;
 };
type Investor = 
 record {
   availableCapital: text;
   bio: opt text;
   city: text;
   company: opt text;
   country: text;
   createdAt: Time;
   email: text;
   fullName: text;
   id: text;
   investmentExperience: text;
   investmentGoals: text;
   location: opt text;
   monthlyBudget: text;
   occupation: opt text;
   phone: text;
   "principal": principal;
   profilePhoto: opt text;
   riskTolerance: text;
   updatedAt: Time;
 };
type FundingStatusResponse = 
 variant {
   Error: text;
   Success: FundingStatus;
 };
type FundingStatus = 
 record {
   fundingGoal: nat;
   fundingMilestones: vec FundingMilestone;
   fundingStatus: text;
   isFullyFunded: bool;
   progressPercentage: nat;
   recentInvestments: vec RecentInvestment;
   remainingAmount: nat;
   totalRaised: nat;
 };
type FundingMilestone = 
 record {
   achievedDate: opt Time;
   isAchieved: bool;
   milestone: text;
   targetAmount: nat;
 };
type FounderRegistrationRequest = 
 record {
   address: text;
   email: text;
   experience: text;
   expertise: text;
   fullName: text;
   idNumber: text;
   linkedIn: text;
   phone: text;
   previousBusinesses: text;
   taxNumber: text;
 };
type Founder = 
 record {
   address: text;
   createdAt: Time;
   email: text;
   experience: text;
   expertise: text;
   fullName: text;
   id: text;
   idNumber: text;
   linkedIn: text;
   phone: text;
   previousBusinesses: text;
   "principal": principal;
   taxNumber: text;
   updatedAt: Time;
 };
type FeedbackType = 
 variant {
   Negative;
   Neutral;
   Positive;
 };
type EnvironmentConfig = 
 record {
   ckUSDCToken: TokenConfig;
   environment: text;
   icpToken: TokenConfig;
   nftToken: NFTConfig;
   plantifyAccount: text;
   useTestTokens: bool;
 };
type DashboardOverviewResponse = 
 variant {
   Error: text;
   Success: DashboardOverview;
 };
type DashboardOverview = 
 record {
   activeStartups: nat;
   draftStartups: nat;
   pendingStartups: nat;
   totalFundingRaised: nat;
   totalMonthlyCommitments: nat;
   totalNFTHolders: nat;
 };
type CollateralTopUpSummary = 
 record {
   amount: nat;
   id: text;
   status: text;
   timestamp: Time;
   transactionId: opt text;
 };
type CollateralTopUp = 
 record {
   amount: nat;
   id: text;
   startupId: text;
   status: text;
   timestamp: Time;
   tokenType: text;
   transactionId: opt text;
 };
type CollateralStatus = 
 variant {
   Active;
   Locked;
   Pending;
   Released;
 };
type CollateralProgressResponse = 
 variant {
   Error: text;
   Success: CollateralProgress;
 };
type CollateralProgress = 
 record {
   currentAmount: nat;
   isFullyPaid: bool;
   percentage: nat;
   requiredAmount: nat;
   status: text;
   tokenType: text;
 };
type CollateralInfo = 
 record {
   createdAt: Time;
   currentAmount: nat;
   lockEndTime: opt Time;
   lockStartTime: opt Time;
   requiredAmount: nat;
   startupId: text;
   status: CollateralStatus;
   tokenType: text;
   topUpHistory: vec CollateralTopUp;
   updatedAt: Time;
 };
type CollateralDashboardResponse = 
 variant {
   Error: text;
   Success: CollateralDashboard;
 };
type CollateralDashboard = 
 record {
   currentAmount: nat;
   isFullyPaid: bool;
   lockEndTime: opt Time;
   lockStartTime: opt Time;
   nextPaymentDue: opt Time;
   progressPercentage: nat;
   remainingAmount: nat;
   requiredAmount: nat;
   startupId: text;
   status: text;
   tokenType: text;
   topUpHistory: vec CollateralTopUpSummary;
 };
type BalanceResponse = 
 variant {
   Error: text;
   Success: record {
              account: TransferAccount;
              balance: nat;
              tokenType: text;
            };
 };
service : {
  approveMonthlyReport: (reportId: text) -> (Result_1);
  calculateRequiredCollateral: (monthlyProfitSharing: nat, tokenType:
   text) -> (nat);
  canInvestorVote: (reportId: text) -> (Result_23);
  canMintNFT: (startupId: text) -> (Result_23);
  canPurchaseNFT: (investorId: text, startupId: text) -> (Result_23);
  castVote: (request: VoteRequest) -> (Result);
  createMonthlyReport: (request: MonthlyReportRequest) -> (Result_1);
  createStartup: (request: StartupCreationRequest) -> (Result_22);
  createStartupForFounder: (founderId: text, request:
   StartupCreationRequest) -> (Result_22);
  getAllCollateralInfo: () -> (vec CollateralInfo);
  getAllMonthlyReports: () -> (vec MonthlyReport);
  getAllNFTs: () -> (vec NFTInfo);
  getAllPurchases: () -> (vec NFTPurchaseInfo);
  getAllStartups: () -> (vec Startup);
  getAllVotes: () -> (vec InvestorVote);
  getBalance: (account: TransferAccount, tokenType: text) ->
   (BalanceResponse);
  getCanisterVersion: () -> (nat);
  getCkUSDCBalance: (account: TransferAccount) -> (BalanceResponse);
  getCkUSDCTokenConfig: () -> (TokenConfig);
  getCollateralDashboard: (startupId: text) -> (CollateralDashboardResponse);
  getCollateralProgress: (startupId: text) -> (CollateralProgressResponse);
  getCollateralStatus: (startupId: text) -> (Result_21);
  getCollateralTopUpHistory: (startupId: text) -> (Result_20);
  getEnvironment: () -> (text);
  getEnvironmentConfig: () -> (EnvironmentConfig);
  getFeaturedStartup: () -> (opt Startup);
  getFounderByPrincipal: () -> (opt Founder);
  getFounderDashboardOverview: () -> (DashboardOverviewResponse);
  getFounderStartupOverview: (startupId: text) -> (StartupOverviewResponse);
  getFounders: () -> (vec Founder);
  getFundingStatus: (startupId: text) -> (FundingStatusResponse);
  getICPBalance: (account: TransferAccount) -> (BalanceResponse);
  getICPTokenConfig: () -> (TokenConfig);
  getInvestorByPrincipal: () -> (opt Investor);
  getInvestorDashboard: () -> (InvestorDashboardResponse);
  getInvestorDashboardOverview: () -> (InvestorDashboardOverviewResponse);
  getInvestorPerformance: () -> (InvestorPerformanceResponse);
  getInvestorProfile: () -> (opt Investor);
  getInvestorPurchaseHistory: (investorId: text) -> (Result_9);
  getInvestorStartupInvestment: (startupId: text) ->
   (InvestorStartupInvestmentResponse);
  getInvestorVoteForReport: (reportId: text) -> (Result_19);
  getInvestorVoteHistory: (investorId: text) -> (Result_18);
  getInvestors: () -> (vec Investor);
  getMonthlyReport: (reportId: text) -> (Result_1);
  getMonthlyReportStats: () -> (MonthlyReportStats);
  getMonthlyReportsByStartup: (startupId: text) -> (Result_17);
  getMonthlyReportsByStatus: (status: MonthlyReportStatus) ->
   (vec MonthlyReport);
  getMyInvestmentPortfolio: () -> (MyInvestmentPortfolioResponse);
  getNFTBalance: (account: NFTAccount) -> (Result_16);
  getNFTInfo: (tokenId: nat) -> (Result_15);
  getNFTOwner: (tokenId: nat) -> (Result_14);
  getNFTPrice: (startupId: text) -> (Result_13);
  getNFTStats: () ->
   (record {
      nextTokenId: nat;
      totalStartups: nat;
      totalSupply: nat;
    });
  getNFTsByStartup: (startupId: text) -> (Result_12);
  getPlantifyAccount: () -> (text);
  getPurchaseInfo: (purchaseId: text) -> (Result_11);
  getPurchaseStats: () -> (NFTPurchaseStats);
  getReportVoteDetails: (reportId: text) -> (Result_10);
  getReportVotes: (reportId: text) -> (vec InvestorVote);
  getStartupDetails: (startupId: text) -> (opt Startup);
  getStartupPurchaseHistory: (startupId: text) -> (Result_9);
  getStartupTeamMembers: (startupId: text) -> (TeamMembersResponse);
  getStartupsByFounderNameAndId: (founderName: text, founderId: text) ->
   (vec Startup);
  getStartupsByFounderPrincipal: () -> (vec Startup);
  getStartupsByFounderPrincipalPaginated: (params: PaginationParams) ->
   (PaginatedStartups);
  getStartupsCount: () -> (nat);
  getStartupsPaginated: (params: PaginationParams) -> (PaginatedStartups);
  getTokenCanisterId: (tokenType: text) -> (opt text);
  getTokenInfo: (tokenType: text) -> (TokenInfoResponse);
  getUserType: () -> (opt UserType);
  getVoteSummary: (reportId: text) -> (Result_8);
  getVotingStats: () -> (VotingStats);
  initializeCollateral: (startupId: text, requiredAmount: nat, tokenType:
   text) -> (Result_6);
  isUserFounder: () -> (bool);
  isUserInvestor: () -> (bool);
  isUsingTestTokens: () -> (bool);
  mintNFT: (request: MintNFTRequest) -> (Result_7);
  mintNFTForStartup: (startupId: text) -> (Result_6);
  purchaseNFT: (request: NFTPurchaseRequest) -> (NFTPurchaseResponse);
  registerFounder: (request: FounderRegistrationRequest) -> (Result_5);
  registerInvestor: (request: InvestorRegistrationRequest) -> (Result_2);
  rejectMonthlyReport: (reportId: text) -> (Result_1);
  submitMonthlyReport: (reportId: text) -> (Result_1);
  topUpCollateral: (request: TopUpRequest) -> (Result_4);
  transferCkUSDC: (toAccount: TransferAccount, amount: nat, memo:
   opt text) -> (TransferResponse);
  transferICP: (toAccount: TransferAccount, amount: nat, memo: opt text) ->
   (TransferResponse);
  transferNFT: (request: TransferNFTRequest) -> (Result_3);
  transferTokens: (args: TransferArgs) -> (TransferResponse);
  updateInvestorProfile: (request: InvestorProfileUpdateRequest) ->
   (Result_2);
  updateMonthlyReport: (reportId: text, request: MonthlyReportRequest) ->
   (Result_1);
  updateStartupStatus: (startupId: text, newStatus: text) -> (bool);
  updateVote: (reportId: text, request: VoteRequest) -> (Result);
  whoami: () -> (principal);
}
